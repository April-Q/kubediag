package elasticsearchquery

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	elasticsearch "github.com/elastic/go-elasticsearch/v7"
	"github.com/go-logr/logr"
	"github.com/jmoiron/jsonq"
	diagnosisv1 "github.com/kubediag/kubediag/api/v1"
	"github.com/kubediag/kubediag/pkg/util"
	"github.com/robfig/cron"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

var (
	// ElasticsearchQueryGeneratedDiagnosisPrefix is the name prefix for diagnoses generated by elasticsearch query.
	ElasticsearchQueryGeneratedDiagnosisPrefix = "elasticsearch-query"
	// ElasticsearchQueryAnnotation is the annotation used to store the elasticsearch query that triggers a diagnosis.
	ElasticsearchQueryAnnotation = util.KubeDiagPrefix + ElasticsearchQueryGeneratedDiagnosisPrefix
	// ElasticsearchHitAnnotation is the annotation used to store the elasticsearch query results.
	ElasticsearchHitAnnotation = util.KubeDiagPrefix + "elasticsearch-hit"
)

// queryHandler performs the defined elasticsearch query at the specified interval and create diagnosis.
type queryHandler struct {
	// trigger defines the rule config and other details queryhandler needs.
	trigger *diagnosisv1.Trigger
	// client knows how to perform CRUD operations on Kubernetes objects.
	client client.Client
	// esclient prefrom operations on elasticsearch.
	esclient elasticsearch.Client
	// Logger represents the ability to log messages.
	logr.Logger
	// Context carries values across API boundaries.
	context.Context
	// stopch terminates the run() method when closed
	stopCh chan struct{}
}

// run runs the queryhanler.
func (qh *queryHandler) run() error {
	var (
		now  = time.Now()
		next = now
	)

	ruleconfig := qh.trigger.Spec.SourceTemplate.ElasticSearchQueryTemplate.RuleConfig
	sche, err := cron.Parse(ruleconfig.CronSchedule)
	if err != nil {
		return err
	}

	for {
		select {
		case <-qh.stopCh:
			return nil
		case <-time.After(next.Sub(now)):
			data, err := qh.queryByRuleconfig()
			if err != nil {
				qh.Error(err, "error in query elasticsearch")
				break
			}
			// create diagnosis
			err = qh.createDiagnosisWithData(data)
			if err != nil {
				qh.Error(err, "error in create diagnosis")
			}
		}
		now = time.Now()
		next = sche.Next(now)
	}
}

// queryByRuleconfig do query in elasticsearch with ruleconfig
func (qh *queryHandler) queryByRuleconfig() (map[string]interface{}, error) {
	ruleconfig := qh.trigger.Spec.SourceTemplate.ElasticSearchQueryTemplate.RuleConfig

	// Build the request body.
	var queryBody map[string]interface{}
	if err := json.NewDecoder(bytes.NewBufferString(ruleconfig.Body)).Decode(&queryBody); err != nil {
		return nil, fmt.Errorf("Error JSON-decoding 'body' field: %v", err)
	}
	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(queryBody); err != nil {
		return nil, fmt.Errorf("Error encoding querybody: %s", err)
	}

	// Perform the search request.
	res, err := qh.esclient.Search(
		qh.esclient.Search.WithContext(qh),
		qh.esclient.Search.WithIndex(ruleconfig.Index),
		qh.esclient.Search.WithBody(&buf),
		qh.esclient.Search.WithTrackTotalHits(true),
		qh.esclient.Search.WithPretty(),
		qh.esclient.Search.WithTimeout(5*time.Second),
	)
	if err != nil {
		return nil, fmt.Errorf("Error getting response: %s", err)
	}

	defer res.Body.Close()

	if res.IsError() {
		var e map[string]interface{}
		if err := json.NewDecoder(res.Body).Decode(&e); err != nil {
			return nil, fmt.Errorf("Error parsing the response body: %s", err)
		} else {
			// Print the response status and error information.
			return nil, fmt.Errorf("[%s] %s: %s",
				res.Status(),
				e["error"].(map[string]interface{})["type"],
				e["error"].(map[string]interface{})["reason"],
			)
		}
	}

	var data map[string]interface{}
	if err := json.NewDecoder(res.Body).Decode(&data); err != nil {
		return nil, fmt.Errorf("Error parsing the response body: %s", err)
	}
	// Print the response status, number of results, and request duration.
	qh.Info(
		"query status", "status:", res.Status(),
		"hit_total:", int(data["hits"].(map[string]interface{})["total"].(map[string]interface{})["value"].(float64)),
		"took:", int(data["took"].(float64)),
	)

	return data, nil
}

// createDiagnosisWithData create diagnosis with query data.
func (qh *queryHandler) createDiagnosisWithData(respData map[string]interface{}) error {
	queryTemplate := qh.trigger.Spec.SourceTemplate.ElasticSearchQueryTemplate

	for _, hit := range respData["hits"].(map[string]interface{})["hits"].([]map[string]interface{}) {
		// match trigger : assume get trigger name from hit
		name := fmt.Sprintf("%s.%s.%s", ElasticsearchQueryGeneratedDiagnosisPrefix, qh.trigger.Name, time.Now().Format("20060102150405"))
		namespace := util.DefautlNamespace
		annotations := make(map[string]string)
		annotations[ElasticsearchQueryAnnotation] = fmt.Sprintf("%v", queryTemplate)

		var doc map[string]interface{}
		source, err := json.Marshal(hit["_source"])
		if err != nil {
			return err
		}
		if err := json.NewDecoder(bytes.NewBuffer(source)).Decode(&doc); err != nil {
			return err
		}

		diagnosis := diagnosisv1.Diagnosis{
			ObjectMeta: metav1.ObjectMeta{
				Name:        name,
				Namespace:   namespace,
				Annotations: annotations,
			},
			Spec: diagnosisv1.DiagnosisSpec{
				OperationSet: qh.trigger.Spec.OperationSet,
			},
		}

		// Add podReference or nodename in diagnosis
		podReference := new(diagnosisv1.PodReference)
		if queryTemplate.PodNamespaceReferenceLabel != "" {
			// value, err := fetchObjectFromMap(doc, string(queryTemplate.PodNamespaceReferenceLabel))
			value, ok := doc[string(queryTemplate.PodNamespaceReferenceLabel)]
			if ok {
				podReference.Namespace = value.(string)
			}
		}
		if queryTemplate.PodNameReferenceLabel != "" {
			value, ok := doc[string(queryTemplate.PodNameReferenceLabel)]
			if ok {
				podReference.Name = value.(string)
			}
		}
		if queryTemplate.ContainerReferenceLabel != "" {
			value, ok := doc[string(queryTemplate.ContainerReferenceLabel)]
			if ok {
				podReference.Container = value.(string)
			}
		}
		if podReference.Namespace != "" && podReference.Name != "" {
			diagnosis.Spec.PodReference = podReference
		}
		if queryTemplate.NodeNameReferenceLabel != "" {
			value, ok := doc[string(queryTemplate.NodeNameReferenceLabel)]
			if ok {
				diagnosis.Spec.NodeName = value.(string)
			}
		}

		// Add parameters in diagnosis.
		parameters := make(map[string]string)
		for _, label := range queryTemplate.ParameterInjectionLabels {
			value, ok := doc[string(label)]
			if ok {
				parameters[string(label)] = value.(string)
			}
		}
		diagnosis.Spec.Parameters = parameters

		// folk diagnosis nodename
		diagnosis.Spec.NodeName = "shujiang-virtualbox"
		if err := qh.client.Create(qh, &diagnosis); err != nil {
			qh.Error(err, "unable to create Diagnosis", "name", diagnosis.Name)
			continue
		}
	}

	return nil
}

// fetchObjectFromMap fetch object from respData
func fetchObjectFromMap(respData map[string]interface{}, lablePath string) (interface{}, error) {
	lp := strings.Split(lablePath, ".")
	jq := jsonq.NewQuery(respData)
	return jq.Interface(lp...)
}
